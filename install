#!/usr/bin/env sh

set -u

type curl > /dev/null || { echo "curl: not found"; exit 1; }

set -e

get_latest_release() {
  local repo="$1"
	curl -sSL "https://api.github.com/repos/${repo}/releases/latest" | \
    awk 'BEGIN{FS=": |,|\""}; /tag_name/{print $5}'
}

repo="hantbk/vtsbackup"
version="$(get_latest_release "${repo}")" 

# if args has version override it and not eq "latest"
if test $# -eq 1; then
  if test "$1" != "latest"; then
     version="$1"

     echo "Install ${version}"
  fi
fi

platform="$(uname | tr "[A-Z]" "[a-z]")"  # Linux => linux
arch="$(uname -m | sed 's/x86_64/amd64/' | sed 's/aarch64/arm64/')" # x86_64 => amd64, aarch64 => arm64

package="vtsbackup-${platform}-${arch}.tar.gz"
package_url="https://github.com/${repo}/releases/download/${version}/${package}"
bin="vtsbackup"
dest_dir="/usr/local/bin"
bin_path="${dest_dir}/${bin}"
tmp_dir="$(mktemp -d)"

trap "rm -r ${tmp_dir}" EXIT

if test -e "${bin_path}"; then
   current_version="v$("${bin_path}" -v | awk '{print $NF}')"
   if test "${current_version}" = "${version}"; then
     echo "${bin} is already updated, no need to upgrade."
     exit 0
   else
     echo "There is a new version of ${bin}, starting to upgrade from ${current_version} to ${version}."
   fi
fi

cd "${tmp_dir}"
curl -sSL "${package_url}" | tar xzf -

if test $(id -u) -eq 0; then
   mv "${bin}" "${dest_dir}"
else
   sudo mv "${bin}" "${dest_dir}"
fi

mkdir -p ~/.vtsbackup

cat <<EOF> ~/.vtsbackup/vtsbackup.yml
# Default VTSBackup configuration
models:
  default:
    description: "Default backup scenario"
    archive:
      includes:
        - /path/to/backup/  # Replace with actual path
    schedule:
      cron: "0 0 * * *"  # Run daily at midnight
    compress_with:
      type: tgz
    storages:
      local:
        type: local
        path: /path/to/local/backups  # Replace with actual path
      minio:
        type: minio
        bucket: your-bucket-name  # Replace with actual bucket name
        endpoint: http://your-minio-endpoint:9000  # Replace with actual endpoint
        path: backups
        access_key_id: ${MINIO_ACCESS_KEY_ID}
        secret_access_key: ${MINIO_SECRET_ACCESS_KEY}
EOF

cat <<EOF > ~/.vtsbackup/snapshot.yml
# ------- CONF SECTION --------
#
# Default number of snapshots kept when run
# Override with --snapshots NUMBER (-s NUMBER) argument
#
SNAPSHOT_COUNT: 10

# Email address for errors, assign directly or read from file. Comment out either, or both if you don't want any mails.
# Sends the following errors: "Missing destination", "Backup currently running" and "Diskspace warning".

# Name of small info file created in DEST_PATH after completed backup
#
INFO_FILE: "backup_info.txt"

# Include a list of the directories which contain changed files since the last snapshot
#
SHOW_CHANGED_DIRS: "yes"

# Arguments to rsync
# -a equals -rlptgoD.  --protect-args improves handling of filenames with spaces.
# Override with --rsync-args ARGS (-r ARGS) argument (arguments without dash here, eg. --rsync-args rlptD
#
RSYNC_ARGS: "-a --protect-args"

# Backup permissions to separate file, "yes" or "no". This should not be needed on most systems.
# This file may be large and will take up space in each snapshot.
# This will only work if source is locally mounted and getfacl is installed
#
BACKUP_PERMISSIONS: "no"

# Logfile, make sure it's writable by the user running the script
LOGFILE: "/var/log/snapshotbackup.log"

# Set error level for less free space on destination than total source size
# "ERROR" aborts the script, "WARNING" only writes log and sends mail
# Note that the backup might still complete if there is enough space for the current snapshot.
#
SPACE_ERRORLEVEL: "WARNING"
#
# ------ END OF CONF SECTION ------

EOF

echo "${bin} ${version} has been installed."